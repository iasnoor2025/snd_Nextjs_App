import { RentalService } from './rental-service';

// ERPNext configuration
const ERPNEXT_URL = process.env.NEXT_PUBLIC_ERPNEXT_URL || process.env.ERPNEXT_URL;
const ERPNEXT_API_KEY = process.env.NEXT_PUBLIC_ERPNEXT_API_KEY || process.env.ERPNEXT_API_KEY;
const ERPNEXT_API_SECRET = process.env.NEXT_PUBLIC_ERPNEXT_API_SECRET || process.env.ERPNEXT_API_SECRET;

interface ERPNextInvoiceItem {
  item_code: string;
  item_name: string;
  description?: string;
  qty: number;
  rate: number;
  amount: number;
  uom: string;
  income_account?: string;
}

interface ERPNextInvoiceData {
  customer: string;
  customer_name?: string;
  posting_date: string;
  due_date: string;
  set_posting_time?: number; // Enable "Edit Posting Date and Time"
  custom_from?: string; // ERPNext custom From date field
  custom_to?: string; // ERPNext custom To date field
  from_date?: string; // ERPNext from_date field
  to_date?: string; // ERPNext to_date field
  custom_subject?: string; // ERPNext custom subject field
  items: ERPNextInvoiceItem[];
  taxes_and_charges?: string;
  taxes_and_charges_table?: any[];
  taxes?: any[]; // Add taxes field as alternative
  tax_amount?: number;
  total?: number;
  grand_total?: number;
  outstanding_amount?: number;
  currency: string;
  conversion_rate?: number;
  selling_price_list?: string;
  price_list_currency?: string;
  plc_conversion_rate?: number;
  company: string;
  doctype: string;
  base_total?: number;
  base_grand_total?: number;
  base_total_taxes_and_charges?: number;
  total_taxes_and_charges?: number;
  base_rounded_total?: number;
  rounded_total?: number;
}

export interface ERPNextDoc {
  name: string;
  owner: string;
  creation: string;
  modified: string;
  modified_by: string;
  docstatus: number;
  idx: number;
}

export interface ERPNextInvoice extends ERPNextInvoiceData, ERPNextDoc {
  status: string;
}

export class ERPNextInvoiceService {
  private static async makeERPNextRequest<T = any>(endpoint: string, options: RequestInit = {}): Promise<any> {
    // Enhanced configuration validation

    if (!ERPNEXT_URL || !ERPNEXT_API_KEY || !ERPNEXT_API_SECRET) {
      const missingVars: string[] = [];
      if (!ERPNEXT_URL) missingVars.push('NEXT_PUBLIC_ERPNEXT_URL');
      if (!ERPNEXT_API_KEY) missingVars.push('NEXT_PUBLIC_ERPNEXT_API_KEY');
      if (!ERPNEXT_API_SECRET) missingVars.push('NEXT_PUBLIC_ERPNEXT_API_SECRET');

      throw new Error(
        `ERPNext configuration is missing. Please check your environment variables: ${missingVars.join(', ')}`
      );
    }

    // Normalize URL - ensure it doesn't have trailing slash, endpoint should start with /
    const baseUrl = ERPNEXT_URL.endsWith('/') ? ERPNEXT_URL.slice(0, -1) : ERPNEXT_URL;
    const normalizedEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    const url = `${baseUrl}${normalizedEndpoint}`;

    const defaultHeaders = {
      Authorization: `token ${ERPNEXT_API_KEY}:${ERPNEXT_API_SECRET}`,
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...defaultHeaders,
          ...options.headers,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage = `ERPNext API error: ${response.status} ${response.statusText}`;

        // Log full error for debugging
        console.error('=== ERPNext API Error ===');
        console.error('URL:', url);
        console.error('Status:', response.status, response.statusText);
        console.error('Error Response:', errorText);

        // For 404 errors, provide more specific guidance
        if (response.status === 404) {
          errorMessage += ` - Endpoint not found: ${url}. `;
          errorMessage += `This usually means: 1) The doctype 'Sales Invoice' doesn't exist or has a different name, `;
          errorMessage += `2) Your API key doesn't have permissions to access this resource, `;
          errorMessage += `3) The ERPNext API endpoint structure is different. `;
          errorMessage += `Please check your ERPNext instance and API key permissions.`;
        }

        // For 417 errors, provide guidance about data validation
        if (response.status === 417) {
          errorMessage += ` - Expectation Failed. `;
          errorMessage += `This usually means: 1) Required fields are missing or invalid, `;
          errorMessage += `2) Data validation failed on ERPNext side, `;
          errorMessage += `3) The invoice data structure doesn't match ERPNext requirements. `;
          errorMessage += `Please check the invoice data and ensure all required fields are present and valid.`;
        }

        // Try to parse error details if available
        try {
          const errorJson = JSON.parse(errorText);
          console.error('=== Full ERPNext Error Response ===');
          console.error(JSON.stringify(errorJson, null, 2));

          // Extract the full exception traceback if available
          if (errorJson.exc) {
            const excMessage = errorJson.exc;
            console.error('=== Full Exception Traceback ===');
            console.error(excMessage);

            // Try to extract the specific field that's causing the issue
            if (typeof excMessage === 'string') {
              // Look for field names in the error
              const fieldMatch = excMessage.match(/Field\s+['"]([^'"]+)['"]/i) ||
                excMessage.match(/['"]([^'"]+)['"]\s+is\s+required/i) ||
                excMessage.match(/['"]([^'"]+)['"]\s+is\s+invalid/i);
              if (fieldMatch) {
                console.error(`=== Problematic Field: ${fieldMatch[1]} ===`);
              }

              // Look for item-related errors
              if (excMessage.includes('Item') || excMessage.includes('item')) {
                console.error('=== Item-related error detected ===');
                const itemMatch = excMessage.match(/Item[^@]*@node\s*\((\d+)-(\d+)\)/i);
                if (itemMatch) {
                  console.error(`Item node range: ${itemMatch[1]}-${itemMatch[2]}`);
                  console.error('This suggests an issue with a specific item in the items array');
                }
              }

              errorMessage += ` Details: ${excMessage.substring(0, 1500)}`;
            }
          }

          // Special handling for 417 Expectation Failed
          if (response.status === 417) {
            console.error('*** 417 EXPECTATION FAILED DETAILS ***');
            console.error(JSON.stringify(errorJson, null, 2));

            // Extract more specific field errors if present
            const firstError = errorJson.exc_messages ? JSON.parse(errorJson.exc_messages[0]) : null;
            const specificMsg = firstError?.message || errorJson.message || 'Validation failed';
            errorMessage += ` 417 Specifics: ${specificMsg}`;
          }

          if (errorJson.message) {
            console.error('=== Error Message ===');
            console.error(errorJson.message);
            errorMessage += ` Details: ${errorJson.message.substring(0, 500)}`;
          } else if (errorJson.error) {
            errorMessage += ` Details: ${errorJson.error}`;
          } else {
            errorMessage += ` Response: ${errorText.substring(0, 500)}`;
          }
        } catch {
          console.error('=== Raw Error Response (not JSON) ===');
          console.error(errorText);
          errorMessage += ` Response: ${errorText.substring(0, 500)}`;
        }

        throw new Error(errorMessage);
      }

      const responseData = await response.json();

      return responseData;
    } catch (fetchError) {
      if (fetchError instanceof Error) {
        // Check if it's a network/connection error
        if (fetchError.message.includes('fetch failed') ||
          fetchError.message.includes('ECONNREFUSED') ||
          fetchError.message.includes('ENOTFOUND') ||
          fetchError.message.includes('timeout')) {
          throw new Error(
            `Network error connecting to ERPNext at ${baseUrl}: ${fetchError.message}. Please check your ERPNext server and network connection.`
          );
        }
        // Re-throw if it's already a formatted error
        throw fetchError;
      } else {
        throw new Error('Unknown network error connecting to ERPNext');
      }
    }
  }

  static async createInvoice(invoiceData: ERPNextInvoiceData): Promise<ERPNextInvoice> {
    try {
      // Enhanced configuration validation
      if (!ERPNEXT_URL || !ERPNEXT_API_KEY || !ERPNEXT_API_SECRET) {
        throw new Error('ERPNext configuration is missing');
      }

      // 1. Data Validation
      if (!invoiceData.customer) throw new Error('Customer is required');
      if (!invoiceData.items || invoiceData.items.length === 0) throw new Error('Items are required');

      // 2. KSA VAT Compliance
      // Check if taxes are present, if not add them
      if (!invoiceData.taxes || invoiceData.taxes.length === 0) {
        try {
          const companyName = invoiceData.company || 'Samhan Naser Al-Dosri Est';
          const taxAccount = await this.findSuitableTaxAccount(companyName);
          invoiceData.taxes = [{
            charge_type: 'On Net Total',
            account_head: taxAccount,
            description: 'VAT 15%',
            rate: 15
          }];
          console.log(`Added KSA compliance tax table (VAT 15%) with account: ${taxAccount}`);
        } catch (error) {
          console.warn('Failed to add default tax table:', error);
          // Continue without taxes if we can't find the account, ERPNext might handle it or reject it
        }
      }

      // 3. Send to ERPNext
      console.log('=== Creating Generic Invoice in ERPNext ===');
      console.log('Customer:', invoiceData.customer);
      console.log('Items Count:', invoiceData.items.length);

      let response;
      try {
        console.log('Attempting Resource API: /api/resource/Sales Invoice');
        response = await this.makeERPNextRequest('/api/resource/Sales Invoice', {
          method: 'POST',
          body: JSON.stringify(invoiceData),
        });
        console.log('Resource API Success:', response?.data?.name || response?.name || 'No name in response');
      } catch (firstError) {
        console.error('Resource API Failed:', firstError instanceof Error ? firstError.message : String(firstError));

        // If resource API fails with 404 or 417, try method-based API
        if (firstError instanceof Error && (firstError.message.includes('404') || firstError.message.includes('417'))) {
          try {
            console.log('Attempting Method API: /api/method/frappe.client.insert');
            response = await this.makeERPNextRequest('/api/method/frappe.client.insert', {
              method: 'POST',
              body: JSON.stringify({
                doc: invoiceData
              }),
            });
            console.log('Method API Success:', response?.data?.name || response?.name || 'No name in response');
          } catch (secondError) {
            throw new Error(
              `Failed to create invoice in ERPNext using both Resource and Method APIs. ` +
              `Original error: ${firstError instanceof Error ? firstError.message : String(firstError)}. ` +
              `Secondary error: ${secondError instanceof Error ? secondError.message : String(secondError)}`
            );
          }
        } else {
          throw firstError;
        }
      }

      return response.data || response;

    } catch (error) {
      console.error('Error creating invoice:', error);
      throw error;
    }
  }

  /**
   * Safe date formatting that stays in local time to avoid timezone shifts
   */
  private static formatDate(date: Date): string {
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  static async createRentalInvoice(rental: any, invoiceNumber: string, billingMonth?: string): Promise<ERPNextInvoice> {
    try {
      // Get the actual company name from ERPNext to ensure it matches
      let companyName = 'Samhan Naser Al-Dosri Est';
      try {
        const companyResponse = await this.makeERPNextRequest('/api/resource/Company?limit_page_length=1');
        if (companyResponse.data && companyResponse.data.length > 0) {
          companyName = companyResponse.data[0].name;
          console.log(`Using company name from ERPNext: ${companyName}`);
        } else {
          console.warn('Could not fetch company from ERPNext, using default:', companyName);
        }
      } catch (companyError) {
        console.warn('Could not fetch company name from ERPNext, using default:', companyName, companyError);
      }

      // Get a suitable income account for the company
      const incomeAccount = await this.findSuitableIncomeAccount();

      // Enhanced rental data validation

      if (!rental.customer?.name && !rental.customerName && !rental.customerId) {
        throw new Error('Customer information is required for invoice generation');
      }

      // Always use the rental's calculated amounts (subtotal, taxAmount, totalAmount)
      // These should be pre-calculated and accurate
      const subtotal = parseFloat(rental.subtotal?.toString() || '0') || 0;
      const taxAmount = parseFloat(rental.taxAmount?.toString() || '0') || 0;
      const totalAmount = parseFloat(rental.totalAmount?.toString() || '0') || 0;
      if (totalAmount <= 0) {
        throw new Error('Rental must have a valid total amount');
      }

      // Validate customer exists in ERPNext
      // First, try to get the customer's ERPNext ID from the database
      let validatedCustomerName: string;
      let customerName = rental.customer?.name || rental.customerName || `CUST-${rental.customerId}`;

      // Fetch customer's erpnextId from database if available
      try {
        const { db } = await import('@/lib/db');
        const { customers } = await import('@/lib/drizzle/schema');
        const { eq } = await import('drizzle-orm');

        const customerRecord = await db
          .select({ erpnextId: customers.erpnextId, name: customers.name })
          .from(customers)
          .where(eq(customers.id, rental.customerId || rental.customer?.id || 0))
          .limit(1);

        if (customerRecord.length > 0 && customerRecord[0].erpnextId) {
          validatedCustomerName = customerRecord[0].erpnextId;
          console.log(`Using ERPNext ID for customer: ${validatedCustomerName} (from database)`);

          // CRITICAL: Even if we have an ID, we should verify it exists and is linked
          // Many old records might be unlinked and cause 417 errors
          const verifyDetail = await this.makeERPNextRequest(`/api/resource/Customer/${encodeURIComponent(validatedCustomerName)}`);
          const targetCoTrim = companyName.trim();
          const isLinked = verifyDetail.data?.accounts?.some((a: any) => a.company?.trim() === targetCoTrim) ||
            verifyDetail.data?.companies?.some((c: any) => c.company?.trim() === targetCoTrim) ||
            verifyDetail.data?.default_company?.trim() === targetCoTrim;

          if (!isLinked) {
            console.warn(`Customer ID ${validatedCustomerName} from DB is NOT linked to ${targetCoTrim}. Falling back to search.`);
            validatedCustomerName = customerName;
          }
        } else {
          // If no erpnextId, try to find customer in ERPNext by name
          validatedCustomerName = customerName;
          console.log(`No ERPNext ID found, will search by name: ${customerName}`);
        }
      } catch (dbError) {
        console.warn('Could not fetch customer ERPNext ID from database:', dbError);
        validatedCustomerName = customerName;
      }

      // If we don't have an ERPNext ID, try to find customer in ERPNext by name
      if (!validatedCustomerName || validatedCustomerName === customerName) {
        // Try to find customer in ERPNext
        try {
          // 1. Try search first to find ALL potential variations (e.g. ones with/without spaces)
          const searchFilters = encodeURIComponent(JSON.stringify([
            ['customer_name', 'like', `%${customerName.replace(/&/g, '%').trim()}%`]
          ]));
          const searchResult = await this.makeERPNextRequest(`/api/resource/Customer?filters=${searchFilters}&fields=["name","customer_name"]&limit_page_length=10`);

          if (searchResult.data && searchResult.data.length > 0) {
            console.log(`Found ${searchResult.data.length} potential customer variations in ERPNext.`);

            // 2. Iterate through variations and find the one LINKED to our company
            let linkedCustomerName = null;
            const targetCompany = companyName.trim();

            for (const cand of searchResult.data) {
              try {
                const detail = await this.makeERPNextRequest(`/api/resource/Customer/${encodeURIComponent(cand.name)}`);
                const isLinked = detail.data?.accounts?.some((a: any) => a.company?.trim() === targetCompany) ||
                  detail.data?.companies?.some((c: any) => c.company?.trim() === targetCompany) ||
                  detail.data?.default_company?.trim() === targetCompany;

                if (isLinked) {
                  linkedCustomerName = cand.name;
                  console.log(`✓ Validated customer with company linkage: ${linkedCustomerName}`);
                  break;
                }
              } catch (e) {
                console.warn(`Failed to fetch details for candidate customer ${cand.name}:`, e);
              }
            }

            if (linkedCustomerName) {
              validatedCustomerName = linkedCustomerName;
            } else {
              // 3. Fallback: If no linked record, use exact match if it exists, or the first variation
              const exactMatch = searchResult.data.find((c: any) => c.name === customerName || c.customer_name === customerName);
              validatedCustomerName = exactMatch ? exactMatch.name : searchResult.data[0].name;
              console.warn(`No customer variation found with explicit linkage to "${companyName}". Using fallback: ${validatedCustomerName}`);
            }
          } else {
            // No search results, use original name as last resort
            console.warn(`Customer "${customerName}" not found in ERPNext via search. Using original name.`);
            validatedCustomerName = customerName;
          }
        } catch (customerError) {
          console.warn('Could not validate customer in ERPNext, proceeding anyway:', customerError);
          validatedCustomerName = customerName;
        }
      }

      // Get rental items from the rental service
      const rentalItems = await RentalService.getRentalItems(rental.id);

      // Don't set taxes manually - let ERPNext handle tax calculation
      // If you need specific taxes, use a tax template name instead
      // const taxTemplateName = 'VAT 15%'; // Use if you have a tax template in ERPNext

      // Calculate dates based on billing month if provided
      let postingDate: string;
      let dueDate: string;
      let fromDate: string;
      let toDate: string;
      let invoiceSubject: string;

      if (billingMonth) {
        // Parse the billing month (format: YYYY-MM)
        const [year, month] = billingMonth.split('-');
        const billingYear = parseInt(year);
        const billingMonthNum = parseInt(month);

        // Calculate dates for the billing month - use UTC to avoid timezone issues
        const monthStart = new Date(Date.UTC(billingYear, billingMonthNum - 1, 1, 0, 0, 0, 0)); // First day of billing month
        const monthEnd = new Date(Date.UTC(billingYear, billingMonthNum, 0, 23, 59, 59, 999)); // Last day of billing month

        // For monthly invoices, From date should ALWAYS be the first day of the billing month
        // This ensures consistency and matches the report period
        const calculatedFromDate = monthStart;

        // To date: End of billing month
        const calculatedToDate = monthEnd;

        // Invoice date (posting date): End of billing month
        postingDate = this.formatDate(monthEnd);

        // Payment due date: 30 days after end of billing month
        const calculatedDueDate = new Date(monthEnd);
        calculatedDueDate.setUTCDate(calculatedDueDate.getUTCDate() + 30);
        dueDate = this.formatDate(calculatedDueDate);

        // From/To dates for the billing period - format as YYYY-MM-DD
        fromDate = this.formatDate(monthStart);
        toDate = this.formatDate(monthEnd);

        // Invoice subject - use full month name and year
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
          'July', 'August', 'September', 'October', 'November', 'December'];
        const monthName = monthNames[billingMonthNum - 1];
        invoiceSubject = `Invoice for ${rental.rentalNumber} - ${monthName} ${billingYear}`;
      } else {
        // For non-monthly billing, use provided dates or defaults
        postingDate = rental.invoiceDate || this.formatDate(new Date());
        dueDate = rental.paymentDueDate || this.formatDate(new Date(Date.now() + (rental.paymentTermsDays || 30) * 24 * 60 * 60 * 1000));
        fromDate = rental.customFrom || rental.invoiceDate || this.formatDate(new Date());
        toDate = rental.customTo || rental.paymentDueDate || this.formatDate(new Date(Date.now() + (rental.paymentTermsDays || 30) * 24 * 60 * 60 * 1000));
        invoiceSubject = rental.customSubject || `Invoice for ${rental.rentalNumber} - ${rental.invoiceMonth || 'Monthly Billing'}`;
      }

      // Fetch mandatory accounts and cost center before initializing invoiceData
      const defaultIncomeAccount = await this.findSuitableIncomeAccount();
      const defaultCostCenter = await this.findSuitableCostCenter();
      const receivableAccount = await this.findSuitableReceivableAccount();
      console.log(`ERPNext Defaults: Income=${defaultIncomeAccount}, CostCenter=${defaultCostCenter}, Receivable=${receivableAccount}`);

      // Prepare invoice data - use only standard ERPNext fields
      // Use the validated customer name and company name
      const invoiceData: any = {
        doctype: 'Sales Invoice',
        naming_series: 'ACC-SINV-.YYYY.-', // Use standard naming series found in diagnostics
        customer: validatedCustomerName, // Use validated customer name (ERPNext ID)
        posting_date: postingDate,
        due_date: dueDate,
        company: companyName, // Use company name from ERPNext
        custom_subject: invoiceSubject, // Add invoice subject (custom field in ERPNext)
        debit_to: receivableAccount, // MANDATORY: Receivable account (Debtors - SND)
        custom_from: fromDate, // MANDATORY in their setup
        custom_to: toDate, // MANDATORY in their setup
        currency: 'SAR',
        conversion_rate: 1,
        selling_price_list: 'Standard Selling',
        price_list_currency: 'SAR',
        plc_conversion_rate: 1,
        items: [],
      };

      console.log('=== Invoice Data Prepared ===');
      console.log('Customer:', validatedCustomerName);
      console.log('Posting Date:', postingDate);
      console.log('Due Date:', dueDate);
      console.log('Company:', invoiceData.company);

      // KSA Compliance: MUST include tax rate in Sales Taxes and Charges Table
      // This is REQUIRED - ERPNext will reject invoices without taxes
      // Find the correct tax account for the company
      const taxAccount = await this.findSuitableTaxAccount(companyName);
      console.log(`Using tax account: ${taxAccount} for company: ${companyName}`);

      // Add VAT 15% tax table (required by KSA compliance)
      // Structure matches ERPNext UI: Type="On Net Total", Account Head="Output VAT 15% - SND", Rate=15
      invoiceData.taxes = [
        {
          charge_type: 'On Net Total',
          account_head: taxAccount,
          description: 'VAT 15%',
          rate: 15,
        }
      ];
      console.log('Added KSA compliance tax table (VAT 15%)');

      // Add rental items to invoice
      if (rentalItems.length > 0) {
        // Filter items to only include those active in the billing month (if specified)
        // This matches the report logic - include ALL items that appear in the report (no deduplication)
        let filteredItems = rentalItems;

        if (billingMonth) {
          const [year, month] = billingMonth.split('-');
          const monthStart = new Date(parseInt(year), parseInt(month) - 1, 1);
          const monthEnd = new Date(parseInt(year), parseInt(month), 0);
          monthEnd.setHours(23, 59, 59, 999);

          filteredItems = rentalItems.filter((item: any) => {
            const itemStartDate = item.startDate ? new Date(item.startDate) : null;
            if (!itemStartDate) return false;

            const itemCompletedDate = item.completedDate || (item as any).completed_date;
            let itemEndDate: Date;

            if (itemCompletedDate) {
              itemEndDate = new Date(itemCompletedDate);
            } else if (rental.status === 'completed' && rental.actualEndDate) {
              itemEndDate = new Date(rental.actualEndDate);
            } else {
              itemEndDate = new Date(); // Current date for active items
            }

            // Item must start before or during the month, and end after or during the month
            // This matches the report logic exactly - no deduplication
            return itemStartDate <= monthEnd && itemEndDate >= monthStart;
          });
        }

        // No deduplication - include all items as they appear in the report
        // Sort items by equipment name (like the report does)
        // Group by equipment, sort equipment groups alphabetically, then sort items within each group
        const groupedByEquipment = filteredItems.reduce((acc: any, item: any) => {
          const equipmentName = item.equipmentName || `Equipment ${item.equipmentId}`;
          if (!acc[equipmentName]) {
            acc[equipmentName] = [];
          }
          acc[equipmentName].push(item);
          return acc;
        }, {});

        // Sort items within each equipment group by active status first, then by start date
        Object.keys(groupedByEquipment).forEach(key => {
          groupedByEquipment[key].sort((a: any, b: any) => {
            // First sort by active status (active items first, then completed)
            const aIsActive = a.status === 'active';
            const bIsActive = b.status === 'active';

            if (aIsActive && !bIsActive) return -1; // Active comes first
            if (!aIsActive && bIsActive) return 1; // Active comes first

            // If both have same status, sort by start date
            const dateA = a.startDate ? new Date(a.startDate).getTime() : 0;
            const dateB = b.startDate ? new Date(b.startDate).getTime() : 0;
            if (dateA !== dateB) return dateA - dateB;

            return 0;
          });
        });

        // Flatten and sort equipment groups alphabetically
        const equipmentKeys = Object.keys(groupedByEquipment).sort();
        const sortedItems: any[] = [];
        equipmentKeys.forEach(key => {
          sortedItems.push(...groupedByEquipment[key]);
        });

        // Validate that we have items after filtering
        if (sortedItems.length === 0) {
          throw new Error(
            `No rental items found for billing month ${billingMonth}. ` +
            `Please ensure the rental has active items during this period.`
          );
        }

        // Get or create a generic service item from ERPNext
        // Using a single item for all equipment is more reliable than trying to match each equipment name
        let serviceItemCode: string;
        let serviceItemName: string | undefined;

        const STANDARD_SERVICE_ITEM_CODE = 'RENTAL-SERVICE';

        try {
          // First, try to find an existing service/rental item
          serviceItemCode = await this.findSuitableItemCode();
          console.log(`Found existing service item code: ${serviceItemCode}`);

          // Fetch the actual item name from ERPNext to ensure it matches
          try {
            const itemResponse = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(serviceItemCode)}`);
            serviceItemName = itemResponse.data?.item_name || itemResponse.data?.name;
            console.log(`Service item name from ERPNext: ${serviceItemName}`);
          } catch (itemError) {
            console.warn('Could not fetch item name from ERPNext, will omit item_name:', itemError);
          }
        } catch (codeError) {
          // No suitable item found, try to use or create the standard service item
          console.log(`No suitable service item found, checking for standard item: ${STANDARD_SERVICE_ITEM_CODE}`);

          try {
            // Check if the standard item exists
            const checkResponse = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(STANDARD_SERVICE_ITEM_CODE)}`);
            if (checkResponse.data) {
              serviceItemCode = STANDARD_SERVICE_ITEM_CODE;
              serviceItemName = checkResponse.data.item_name || checkResponse.data.name || 'Rental Service';
              console.log(`Standard service item already exists: ${serviceItemCode}`);
            }
          } catch (checkError) {
            // Item doesn't exist, create it
            console.log(`Standard service item doesn't exist, creating: ${STANDARD_SERVICE_ITEM_CODE}`);

            try {
              // Create the item in ERPNext with all required fields
              const newItemData = {
                doctype: 'Item',
                item_code: STANDARD_SERVICE_ITEM_CODE,
                item_name: 'Rental Service',
                item_group: 'Services',
                stock_uom: 'Nos',
                is_stock_item: 0, // Service item, not stock item
                has_variants: 0,
                include_item_in_manufacturing: 0,
                description: 'Equipment rental service',
              };

              const createResponse = await this.makeERPNextRequest('/api/resource/Item', {
                method: 'POST',
                body: JSON.stringify(newItemData),
              });

              serviceItemCode = STANDARD_SERVICE_ITEM_CODE;
              serviceItemName = createResponse.data?.item_name || createResponse.data?.name || 'Rental Service';
              console.log(`Created new rental service item in ERPNext: ${serviceItemCode}`);

              // Verify the item was created by fetching it
              try {
                const verifyResponse = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(serviceItemCode)}`);
                if (verifyResponse.data) {
                  serviceItemName = verifyResponse.data.item_name || verifyResponse.data.name || serviceItemName;
                  console.log(`Verified service item exists: ${serviceItemCode}, name: ${serviceItemName}`);
                }
              } catch (verifyError) {
                console.warn('Could not verify created item, but continuing:', verifyError);
              }
            } catch (createError) {
              console.error('Failed to create service item in ERPNext:', createError);
              throw new Error(`Failed to create service item in ERPNext: ${createError instanceof Error ? createError.message : String(createError)}. Please create an item manually in ERPNext.`);
            }
          }
        }

        // Final validation - ensure we have a valid item code
        if (!serviceItemCode || serviceItemCode.trim() === '') {
          throw new Error('Failed to get or create a service item. Please create at least one Item in ERPNext before creating invoices.');
        }

        // CRITICAL: Verify the item actually exists in ERPNext and get its exact code
        // If verification fails, try to create it, or use ANY available item as fallback
        let itemVerified = false;
        try {
          const verifyItem = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(serviceItemCode)}`);
          if (!verifyItem.data) {
            throw new Error(`Item "${serviceItemCode}" does not exist in ERPNext`);
          }

          // Use the exact item code from ERPNext (might be different due to naming rules)
          const exactItemCode = verifyItem.data.name || verifyItem.data.item_code || serviceItemCode;
          if (exactItemCode !== serviceItemCode) {
            console.log(`Item code adjusted from "${serviceItemCode}" to "${exactItemCode}" (ERPNext naming rules)`);
            serviceItemCode = exactItemCode;
          }

          // Verify item is enabled and can be used
          if (verifyItem.data.disabled === 1) {
            throw new Error(`Item "${serviceItemCode}" is disabled in ERPNext`);
          }

          console.log(`✓ Verified item exists in ERPNext: ${serviceItemCode}`);
          console.log(`Item details:`, {
            name: verifyItem.data.name,
            item_code: verifyItem.data.item_code,
            item_name: verifyItem.data.item_name,
            item_group: verifyItem.data.item_group,
            is_stock_item: verifyItem.data.is_stock_item,
            stock_uom: verifyItem.data.stock_uom,
            disabled: verifyItem.data.disabled,
            company: verifyItem.data.company
          });

          // Verify item belongs to the company (if company is specified)
          if (companyName && verifyItem.data.company && verifyItem.data.company !== companyName) {
            console.warn(`Item "${serviceItemCode}" belongs to company "${verifyItem.data.company}" but invoice is for "${companyName}". This may cause issues.`);
          }

          // Update serviceItemName from verified item
          serviceItemName = verifyItem.data.item_name || verifyItem.data.name;
          itemVerified = true;
        } catch (verifyError) {
          console.error(`✗ Item verification failed for ${serviceItemCode}:`, verifyError);

          // Try to create the item if it doesn't exist
          if (verifyError instanceof Error && verifyError.message.includes('does not exist')) {
            console.log(`Attempting to create missing item: ${serviceItemCode}`);
            try {
              const newItemData = {
                doctype: 'Item',
                item_code: serviceItemCode,
                item_name: serviceItemName || 'Rental Service',
                item_group: 'Services',
                stock_uom: 'Nos',
                is_stock_item: 0,
                has_variants: 0,
                include_item_in_manufacturing: 0,
                description: 'Equipment rental service',
              };

              const createResponse = await this.makeERPNextRequest('/api/resource/Item', {
                method: 'POST',
                body: JSON.stringify(newItemData),
              });

              console.log(`✓ Created missing item: ${serviceItemCode}`);
              itemVerified = true;
            } catch (createError) {
              console.warn(`Failed to create item ${serviceItemCode}, will try fallback:`, createError);
            }
          }

          // If still not verified, use ANY available item as fallback
          if (!itemVerified) {
            try {
              const availableItems = await this.getAvailableItems();
              if (availableItems.length > 0) {
                // Prefer service items, but use any item if needed
                const serviceItem = availableItems.find(item =>
                  item.item_group?.toLowerCase().includes('service') ||
                  item.item_name?.toLowerCase().includes('service') ||
                  item.item_name?.toLowerCase().includes('rental')
                );

                const fallbackItem = serviceItem || availableItems[0];
                serviceItemCode = fallbackItem.item_code || fallbackItem.name;
                serviceItemName = fallbackItem.item_name || fallbackItem.name;
                console.warn(`Using fallback item: ${serviceItemCode} (${serviceItem ? 'service item' : 'first available item'})`);

                // Verify the fallback item exists
                const fallbackVerify = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(serviceItemCode)}`);
                if (fallbackVerify.data && fallbackVerify.data.disabled !== 1) {
                  itemVerified = true;
                  console.log(`✓ Fallback item verified: ${serviceItemCode}`);
                }
              }
            } catch (fallbackError) {
              console.error('Fallback item selection failed:', fallbackError);
            }
          }
        }

// Final check - if still not verified, throw error
if (!itemVerified) {
    throw new Error(`Item "${serviceItemCode}" does not exist in ERPNext and could not be created or found. Please create at least one Item in ERPNext manually. Original error: ${verifyError instanceof Error ? verifyError.message : String(verifyError)}`);
}
        }


invoiceData.items = await Promise.all(
    sortedItems.map(async (item, index) => {
        // Ensure equipmentName is not empty or undefined from the start
        const equipmentName = (item.equipmentName && item.equipmentName.trim() !== '')
            ? item.equipmentName.trim()
            : `Equipment ${item.equipmentId || item.id || 'Unknown'}`;

        console.log(`Processing item ${index + 1}/${sortedItems.length}: ${equipmentName} (ID: ${item.id || item.equipmentId})`);

        // Sync equipment to ERPNext - this will find existing or create new
        // This ensures all rental equipment has corresponding items in ERPNext
        let itemCode: string;
        try {
            // Pass plateNumber if available (cast item to avoid TS error if property is missing on interface)
            const plateNumber = (item as any).plateNumber || (item as any).plate_number;
            itemCode = await this.syncEquipmentToERPNext(equipmentName, item.equipmentId, plateNumber);
            console.log(`✓ Equipment synced to ERPNext: ${equipmentName} -> ${itemCode}`);
        } catch (syncError) {
            console.warn(`Failed to sync equipment ${equipmentName} to ERPNext, using fallback:`, syncError);
            // Fall back to generic service item
            itemCode = serviceItemCode;
        }

        // Calculate duration based on rate type (this will be used as quantity)
        // IMPORTANT: Quantity should be hours (like the report shows), not days
        const rateType = item.rateType || 'daily';
        const itemStartDate = item.startDate || rental.startDate;
        const itemCompletedDate = item.completedDate || (item as any).completed_date;

        let duration = 1; // Default quantity
        let uom = 'Nos'; // Default UOM

        // For all rate types, try to use actual timesheet hours if available
        // This matches the report which shows hours (e.g., "230 hours")
        // IMPORTANT: Must check timesheet received status first (like the report does)
        let timesheetReceived = false;
        let totalHours = 0;

        try {
            const { db } = await import('@/lib/db');
            const { rentalEquipmentTimesheets, rentalTimesheetReceived } = await import('@/lib/drizzle/schema');
            const { eq, and, gte, lte } = await import('drizzle-orm');

            // Determine date range for timesheet query - MUST match invoice range to prevent 417 logic errors
            const startDateStr = fromDate;
            const endDateStr = toDate;

            // Check timesheet received status (context specific to monthly vs custom range)
            if (billingMonth) {
                const statusRecord = await db
                    .select()
                    .from(rentalTimesheetReceived)
                    .where(
                        and(
                            eq(rentalTimesheetReceived.rentalId, rental.id),
                            eq(rentalTimesheetReceived.rentalItemId, item.id),
                            eq(rentalTimesheetReceived.month, billingMonth)
                        )
                    )
                    .limit(1);

                timesheetReceived = statusRecord[0]?.received || false;
            } else {
                // For custom range, if rental is active and hasTimesheet is set, assume received or check recent
                timesheetReceived = rental.hasTimesheet || false;
            }

            // Fetch timesheet data for this item and period
            const timesheets = await db
                .select()
                .from(rentalEquipmentTimesheets)
                .where(
                    and(
                        eq(rentalEquipmentTimesheets.rentalItemId, item.id),
                        gte(rentalEquipmentTimesheets.date, startDateStr),
                        lte(rentalEquipmentTimesheets.date, endDateStr)
                    )
                );

            // Calculate total hours
            totalHours = timesheets.reduce((sum, ts) => {
                const regular = parseFloat(ts.regularHours?.toString() || '0') || 0;
                const overtime = parseFloat(ts.overtimeHours?.toString() || '0') || 0;
                return sum + regular + overtime;
            }, 0);

            // If timesheet was received and we have hours, use timesheet-based calculation (matches report)
            // This applies to ALL rate types including monthly (report converts monthly to hourly too)
            if (timesheetReceived && totalHours > 0) {
                duration = totalHours; // Use hours directly (e.g., 179 hours) - this becomes qty in invoice
                uom = 'Hour'; // Always use hours when timesheet data is available
            }
        } catch (error) {
            // If timesheet fetch fails, fall through to date-based calculation
            console.error(`Error fetching timesheet for item ${item.id}:`, error);
        }

        // If duration is still 1 (default) or not set from timesheet, calculate from dates
        // Only do this if we didn't get timesheet hours (duration should be > 1 if we have hours)
        if (duration === 1 && uom === 'Nos' && itemStartDate) {
            let startDate = new Date(itemStartDate);
            let endDate: Date;

            // For monthly billing, calculate duration only for the billing month
            if (billingMonth && rental.customFrom && rental.customTo) {
                // Use the billing month period
                startDate = new Date(rental.customFrom);
                endDate = new Date(rental.customTo);

                // Ensure start date is not before item start date
                const itemStart = new Date(itemStartDate);
                if (startDate < itemStart) {
                    startDate = itemStart;
                }

                // Ensure end date is not after item completed date (if exists)
                if (itemCompletedDate) {
                    const itemEnd = new Date(itemCompletedDate);
                    if (endDate > itemEnd) {
                        endDate = itemEnd;
                    }
                }
            } else {
                // For non-monthly billing, use full rental period
                if (itemCompletedDate) {
                    endDate = new Date(itemCompletedDate);
                } else if (rental.status === 'completed' && rental.expectedEndDate) {
                    endDate = new Date(rental.expectedEndDate);
                } else if (rental.customTo) {
                    // Use customTo from invoice if available
                    endDate = new Date(rental.customTo);
                } else {
                    endDate = new Date();
                }
            }

            // Ensure end date is not before start date
            if (endDate < startDate) {
                endDate = startDate;
            }

            const durationMs = endDate.getTime() - startDate.getTime();

            // Calculate duration based on rate type
            if (rateType === 'hourly') {
                duration = Math.max(1, Math.ceil(durationMs / (1000 * 60 * 60)));
                uom = 'Hour';
            } else if (rateType === 'weekly') {
                duration = Math.max(1, Math.ceil(durationMs / (1000 * 60 * 60 * 24 * 7)));
                uom = 'Week';
            } else if (rateType === 'monthly') {
                duration = Math.max(1, Math.ceil(durationMs / (1000 * 60 * 60 * 24 * 30)));
                uom = 'Nos'; // Use "Nos" for monthly rates since ERPNext doesn't support "Month" UOM
            } else {
                // Daily rate - calculate days
                // Add 1 day to make it inclusive (start date to end date = 1 day, not 0)
                duration = Math.max(1, Math.ceil(durationMs / (1000 * 60 * 60 * 24)) + 1);
                uom = 'Day';
            }
        }

        // Calculate amount based on unit price and duration
        // IMPORTANT: Match report calculation exactly
        const unitPrice = parseFloat(item.unitPrice?.toString() || '0') || 0;
        let amount = 0;
        let rate = unitPrice; // Default rate

        // If timesheet was received and we have hours, use timesheet-based calculation (matches report)
        // This applies to ALL rate types including monthly (report converts monthly to hourly too)
        // IMPORTANT: Use the exact hours we calculated (duration should already be set to totalHours)
        if (timesheetReceived && totalHours > 0 && uom === 'Hour' && duration === totalHours) {
            // Convert rate to hourly equivalent based on rate type (matches report logic)
            if (rateType === 'daily') {
                rate = unitPrice / 10; // Daily rate / 10 hours = hourly rate
            } else if (rateType === 'weekly') {
                rate = unitPrice / (7 * 10); // Weekly rate / (7 days * 10 hours) = hourly rate
            } else if (rateType === 'monthly') {
                rate = unitPrice / (30 * 10); // Monthly rate / (30 days * 10 hours) = hourly rate (matches report)
            }
            // If rateType is already 'hourly', rate stays as unitPrice
            // Use duration (which equals totalHours) as the quantity - this matches report exactly
            amount = rate * duration; // hourly rate * hours (duration = totalHours from timesheet)
        } else {
            // Fallback to date-based calculation (matches report when no timesheet or not received)
            if (rateType === 'monthly') {
                // For monthly rates without timesheet, calculate months from dates
                if (billingMonth && rental.customFrom && rental.customTo && itemStartDate) {
                    let startDate = new Date(rental.customFrom);
                    let endDate = new Date(rental.customTo);

                    const itemStart = new Date(itemStartDate);
                    if (startDate < itemStart) {
                        startDate = itemStart;
                    }

                    if (itemCompletedDate) {
                        const itemEnd = new Date(itemCompletedDate);
                        if (endDate > itemEnd) {
                            endDate = itemEnd;
                        }
                    }

                    if (endDate < startDate) {
                        endDate = startDate;
                    }

                    const durationMs = endDate.getTime() - startDate.getTime();
                    duration = Math.max(1, Math.ceil(durationMs / (1000 * 60 * 60 * 24 * 30)));
                    uom = 'Nos'; // Use "Nos" for monthly rates since ERPNext doesn't support "Month" UOM
                } else {
                    duration = 1;
                    uom = 'Nos';
                }
                amount = unitPrice * duration; // monthly rate * number of months
            } else {
                // For other rate types, use date-based calculation
                // Calculate days for the billing month period
                if (billingMonth && rental.customFrom && rental.customTo && itemStartDate) {
                    let startDate = new Date(rental.customFrom);
                    let endDate = new Date(rental.customTo);

                    const itemStart = new Date(itemStartDate);
                    if (startDate < itemStart) {
                        startDate = itemStart;
                    }

                    if (itemCompletedDate) {
                        const itemEnd = new Date(itemCompletedDate);
                        if (endDate > itemEnd) {
                            endDate = itemEnd;
                        }
                    }

                    if (endDate < startDate) {
                        endDate = startDate;
                    }

                    // Calculate inclusive days using timestamps to avoid timezone/DST issues
                    // Set both dates to noon to ensure full days are counted correctly
                    const s = new Date(startDate); s.setHours(12, 0, 0, 0);
                    const e = new Date(endDate); e.setHours(12, 0, 0, 0);
                    const durationMs = e.getTime() - s.getTime();
                    const oneDay = 1000 * 60 * 60 * 24;
                    const days = Math.round(durationMs / oneDay) + 1; // +1 inclusive

                    duration = Math.max(days, 0);
                } else {
                    // Fallback: Calculate duration if not using billing month logic
                    // Use simple inclusive diff
                    const dEnd = itemCompletedDate ? new Date(itemCompletedDate) : new Date();
                    const dStart = new Date(itemStartDate || new Date());

                    // Set to noon to avoid timezone issues
                    dStart.setHours(12, 0, 0, 0);
                    dEnd.setHours(12, 0, 0, 0);

                    const ms = dEnd.getTime() - dStart.getTime();
                    const oneDay = 1000 * 60 * 60 * 24;
                    const dDays = Math.max(1, Math.round(ms / oneDay) + 1);

                    if (rateType === 'daily') duration = dDays;
                }
                amount = unitPrice * duration; // unit price * days
            }
        }

// Final validation - ensure item_code is set
if (!itemCode || itemCode.trim() === '') {
    console.error(`Item validation failed - missing item_code:`, { item, equipmentName, itemCode });
    throw new Error(`Missing item_code for equipment: ${equipmentName || 'Unknown'}`);
}

// equipmentName is guaranteed to be set from initialization above, so no need to check it again
console.log(`Item ${index + 1} validated: item_code=${itemCode}, item_name=${equipmentName}`);

// Build description based on rate type
let description = item.notes;
if (!description) {
    if (rateType === 'monthly') {
        description = `Monthly rental for ${equipmentName} (Asset #${item.equipmentId}) (${duration} month${duration !== 1 ? 's' : ''})`;
    } else {
        description = `Rental of ${equipmentName} (Asset #${item.equipmentId}) (${duration} ${uom}${duration !== 1 ? 's' : ''})`;
    }
}

// Ensure qty, rate, and amount are valid numbers
const finalQty = Math.max(0, duration || 1);
const finalRate = Math.max(0, rate || 0);
const finalAmount = Math.max(0, amount || (finalRate * finalQty));

// Build the item object - use absolute minimal structure
// ERPNext requires: item_code, qty, rate
// Validate all values are valid numbers
if (isNaN(finalQty) || finalQty <= 0) {
    throw new Error(`Invalid quantity for item ${equipmentName}: ${finalQty}`);
}
if (isNaN(finalRate) || finalRate < 0) {
    throw new Error(`Invalid rate for item ${equipmentName}: ${finalRate}`);
}
if (isNaN(finalAmount) || finalAmount < 0) {
    throw new Error(`Invalid amount for item ${equipmentName}: ${finalAmount}`);
}

// Use minimal structure - only required fields
// IMPORTANT: Don't use toFixed() as it returns a string - use Math.round for precision
const mappedItem: any = {
    item_code: itemCode.trim(), // String
    qty: Math.round(finalQty * 100) / 100, // Round to 2 decimals, keep as number
    rate: Math.round(finalRate * 100) / 100, // Round to 2 decimals, keep as number
    amount: Math.round(finalAmount * 100) / 100, // Round to 2 decimals, keep as number
    income_account: defaultIncomeAccount, // Add income account (Sales - SND)
    cost_center: defaultCostCenter, // Add mandatory cost center (Main - SND)
    uom: uom || 'Nos', // Use the calculated UOM (e.g. 'Hour', 'Day', 'Week', or 'Nos')
    conversion_factor: 1, // Standard conversion factor
    base_rate: Math.round(finalRate * 100) / 100, // Matching rate for SAR
    base_amount: Math.round(finalAmount * 100) / 100, // Matching amount for SAR
    _originalEquipmentName: equipmentName, // Store original equipment name for final check
};

// Final validation - ensure all values are valid
if (!mappedItem.item_code || mappedItem.item_code.trim() === '') {
    throw new Error(`Empty item_code for item ${equipmentName}`);
}
if (mappedItem.qty <= 0 || isNaN(mappedItem.qty) || !isFinite(mappedItem.qty)) {
    throw new Error(`Invalid qty for item ${equipmentName}: ${mappedItem.qty}`);
}
if (mappedItem.rate < 0 || isNaN(mappedItem.rate) || !isFinite(mappedItem.rate)) {
    throw new Error(`Invalid rate for item ${equipmentName}: ${mappedItem.rate}`);
}
if (mappedItem.amount < 0 || isNaN(mappedItem.amount) || !isFinite(mappedItem.amount)) {
    throw new Error(`Invalid amount for item ${equipmentName}: ${mappedItem.amount}`);
}

console.log(`Item ${index + 1} structure:`, JSON.stringify(mappedItem));
console.log(`Item ${index + 1} validation:`, {
    item_code: mappedItem.item_code,
    item_code_length: mappedItem.item_code.length,
    qty: mappedItem.qty,
    qty_type: typeof mappedItem.qty,
    rate: mappedItem.rate,
    rate_type: typeof mappedItem.rate,
    amount: mappedItem.amount,
    amount_type: typeof mappedItem.amount
});

return mappedItem;
          })
        );


// Validate that all items were created successfully
if (!invoiceData.items || invoiceData.items.length === 0) {
    throw new Error('Failed to create invoice items. No valid items were generated.');
}

// CRITICAL: Verify ALL items exist in ERPNext before sending
// Match the exact structure that works in the test endpoint
console.log(`=== Verifying ${invoiceData.items.length} items exist in ERPNext ===`);
const verifiedItems: any[] = [];

for (let i = 0; i < invoiceData.items.length; i++) {
    const item = invoiceData.items[i];
    let verifiedItemCode = item.item_code;

    try {
        // Step 1: Try direct lookup with the exact item code
        let verifyItem;
        try {
            verifyItem = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(item.item_code)}`);

            if (verifyItem.data && verifyItem.data.disabled !== 1) {
                // CRITICAL: Check if item is a fixed asset - find or create non-fixed asset version
                if (verifyItem.data.is_fixed_asset === 1 || verifyItem.data.is_fixed_asset === true) {
                    console.warn(`⚠ Item "${item.item_code}" is a fixed asset. Searching for non-fixed asset version...`);

                    // Search for non-fixed asset version with same name
                    // PRIORITIZE item_code (Asset Tag) over item_name (Model Number) to preserve specific asset ID
                    const itemName = verifyItem.data.name || item.item_code;

                    // Double check we aren't using a weird name
                    const searchName = (itemName === verifyItem.data.item_name) ? item.item_code : itemName;

                    const searchResponse = await this.makeERPNextRequest(
                        `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(searchName)}"],["is_fixed_asset","=",0]]&limit_page_length=5`
                    );

                    if (searchResponse.data && searchResponse.data.length > 0) {
                        // Found non-fixed asset version - use it
                        const nonFixedAsset = searchResponse.data.find((it: any) =>
                            (it.item_name || it.name) === searchName && (it.is_fixed_asset === 0 || it.is_fixed_asset === false)
                        ) || searchResponse.data[0];

                        verifiedItemCode = nonFixedAsset.name || nonFixedAsset.item_code;
                        console.log(`✓ Found non-fixed asset version: "${item.item_code}" -> "${verifiedItemCode}"`);
                    } else {
                        // No non-fixed asset version exists - create new one
                        console.log(`Creating new non-fixed asset item for "${searchName}"...`);
                        const normalizedName = searchName.replace(/_/g, ' ').trim();
                        const newItemCode = await this.syncEquipmentToERPNext(normalizedName);
                        verifiedItemCode = newItemCode;
                        console.log(`✓ Created new non-fixed asset item: "${verifiedItemCode}"`);
                    }
                } else {
                    // Item exists and is enabled and not a fixed asset - use the exact code from ERPNext
                    verifiedItemCode = verifyItem.data.name || verifyItem.data.item_code;
                    console.log(`✓ Item ${i + 1}/${invoiceData.items.length} verified (direct): ${verifiedItemCode}`);
                }
            } else if (verifyItem.data && verifyItem.data.disabled === 1) {
                throw new Error(`Item "${item.item_code}" is disabled in ERPNext`);
            } else {
                throw new Error(`Item "${item.item_code}" not found in ERPNext`);
            }
        } catch {
            // Step 2: Direct lookup failed, try searching by item_name
            console.log(`Direct lookup failed for "${item.item_code}", trying search...`);

            // Normalize the item code for search (remove special chars, normalize spaces)
            const searchTerm = item.item_code.replace(/[^a-zA-Z0-9\s]/g, ' ').trim();

            // Try exact match first
            try {
                const exactSearch = await this.makeERPNextRequest(
                    `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(item.item_code)}"]]&limit_page_length=5`
                );

                if (exactSearch.data && exactSearch.data.length > 0) {
                    // Prioritize non-fixed asset items
                    const nonFixedMatch = exactSearch.data.find((it: any) =>
                        (it.item_name || it.name || '').trim() === item.item_code.trim() &&
                        (it.is_fixed_asset === 0 || it.is_fixed_asset === false) &&
                        it.disabled !== 1
                    );

                    const match = nonFixedMatch || exactSearch.data.find((it: any) =>
                        (it.item_name || it.name || '').trim() === item.item_code.trim() && it.disabled !== 1
                    ) || exactSearch.data[0];

                    verifiedItemCode = match.name || match.item_code;

                    // Verify it's not a fixed asset
                    const matchDetails = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(verifiedItemCode)}`);
                    if (matchDetails.data && (matchDetails.data.is_fixed_asset === 1 || matchDetails.data.is_fixed_asset === true)) {
                        // It's a fixed asset - search for non-fixed version or create new
                        // PRIORITIZE item_code (Asset Tag) over item_name (Model Number)
                        const itemName = matchDetails.data.name || verifiedItemCode;

                        // Double check we aren't using a weird name
                        const searchName = (itemName === matchDetails.data.item_name) ? verifiedItemCode : itemName;

                        const nonFixedSearch = await this.makeERPNextRequest(
                            `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(searchName)}"],["is_fixed_asset","=",0]]&limit_page_length=5`
                        );

                        if (nonFixedSearch.data && nonFixedSearch.data.length > 0) {
                            const nonFixedAsset = nonFixedSearch.data.find((it: any) =>
                                (it.item_name || it.name) === searchName && (it.is_fixed_asset === 0 || it.is_fixed_asset === false)
                            ) || nonFixedSearch.data[0];
                            verifiedItemCode = nonFixedAsset.name || nonFixedAsset.item_code;
                            console.log(`✓ Found non-fixed asset version: "${item.item_code}" -> "${verifiedItemCode}"`);
                        } else {
                            // Create new non-fixed asset item
                            console.log(`Creating new non-fixed asset item for "${searchName}"...`);
                            const normalizedName = searchName.replace(/_/g, ' ').trim();
                            verifiedItemCode = await this.syncEquipmentToERPNext(normalizedName);
                            console.log(`✓ Created new non-fixed asset item: "${verifiedItemCode}"`);
                        }
                    } else {
                        console.log(`✓ Item ${i + 1}/${invoiceData.items.length} found by exact name: ${verifiedItemCode}`);
                    }
                } else {
                    throw new Error('No exact match');
                }
            } catch {
                // Step 3: Try like search
                const likeSearch = await this.makeERPNextRequest(
                    `/api/resource/Item?filters=[["item_name","like","${encodeURIComponent(`%${searchTerm}%`)}"]]&limit_page_length=10`
                );

                if (likeSearch.data && likeSearch.data.length > 0) {
                    // Find best match (exact or closest)
                    const normalizedSearch = searchTerm.toUpperCase().replace(/\s+/g, ' ');
                    const bestMatch = likeSearch.data.find((it: any) => {
                        const itName = (it.item_name || it.name || '').toUpperCase().replace(/\s+/g, ' ');
                        return itName === normalizedSearch || itName.includes(normalizedSearch) || normalizedSearch.includes(itName);
                    }) || likeSearch.data[0];

                    verifiedItemCode = bestMatch.name || bestMatch.item_code;

                    // Verify the found item is enabled
                    const finalVerify = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(verifiedItemCode)}`);
                    if (finalVerify.data && finalVerify.data.disabled === 1) {
                        throw new Error(`Found item "${verifiedItemCode}" but it is disabled`);
                    }

                    // CRITICAL: Check if item is a fixed asset - find or create non-fixed asset version
                    if (finalVerify.data && (finalVerify.data.is_fixed_asset === 1 || finalVerify.data.is_fixed_asset === true)) {
                        console.warn(`⚠ Item "${verifiedItemCode}" is a fixed asset. Searching for non-fixed asset version...`);

                        // Search for non-fixed asset version with same name
                        // PRIORITIZE item_code (Asset Tag) over item_name
                        const itemName = finalVerify.data.name || verifiedItemCode;
                        const searchName = (itemName === finalVerify.data.item_name) ? verifiedItemCode : itemName;

                        const searchResponse = await this.makeERPNextRequest(
                            `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(searchName)}"],["is_fixed_asset","=",0]]&limit_page_length=5`
                        );

                        if (searchResponse.data && searchResponse.data.length > 0) {
                            // Found non-fixed asset version - use it
                            const nonFixedAsset = searchResponse.data.find((it: any) =>
                                (it.item_name || it.name) === searchName && (it.is_fixed_asset === 0 || it.is_fixed_asset === false)
                            ) || searchResponse.data[0];

                            verifiedItemCode = nonFixedAsset.name || nonFixedAsset.item_code;
                            console.log(`✓ Found non-fixed asset version: "${item.item_code}" -> "${verifiedItemCode}"`);
                        } else {
                            // No non-fixed asset version exists - create new one
                            console.log(`Creating new non-fixed asset item for "${searchName}"...`);
                            const normalizedName = searchName.replace(/_/g, ' ').trim();
                            const newItemCode = await this.syncEquipmentToERPNext(normalizedName);
                            verifiedItemCode = newItemCode;
                            console.log(`✓ Created new non-fixed asset item: "${verifiedItemCode}"`);
                        }
                    } else {
                        console.log(`✓ Item ${i + 1}/${invoiceData.items.length} found by search: "${item.item_code}" -> "${verifiedItemCode}"`);
                    }
                } else {
                    throw new Error(`Item "${item.item_code}" not found in ERPNext (searched: "${searchTerm}")`);
                }
            }
        }

        // Create verified item with ONLY the minimal fields (matching test endpoint)
        // Store original equipment name for final check if needed
        verifiedItems.push({
            item_code: verifiedItemCode.trim(),
            qty: Math.round(item.qty * 100) / 100,
            rate: Math.round(item.rate * 100) / 100,
            amount: Math.round(item.amount * 100) / 100,
            uom: item.uom || 'Nos',
            income_account: item.income_account || defaultIncomeAccount,
            cost_center: item.cost_center || defaultCostCenter,
            _originalEquipmentName: item._originalEquipmentName || item.item_code, // Store original name
        });

    } catch (verifyError) {
        console.error(`✗ Item ${i + 1}/${invoiceData.items.length} verification failed: ${item.item_code}`);
        console.error(`Error details:`, verifyError);
        throw new Error(
            `Item "${item.item_code}" does not exist or is invalid in ERPNext. ` +
            `Please ensure the equipment exists in ERPNext or it will be created automatically. ` +
            `Error: ${verifyError instanceof Error ? verifyError.message : String(verifyError)}`
        );
    }
}

// CRITICAL: Ensure we have at least one item
if (verifiedItems.length === 0) {
    throw new Error(
        `No valid items found for invoice. All items were either fixed assets (which require asset selection) or invalid. ` +
        `Please ensure at least one equipment item exists in ERPNext and is not a fixed asset.`
    );
}

// Replace items with verified items (using minimal structure)
const originalItemCount = invoiceData.items.length;

// FINAL CHECK: Verify none of the verified items are fixed assets
// Store original equipment names BEFORE cleaning (from sortedItems)
const originalEquipmentNamesMap = new Map<string, string>();
for (let idx = 0; idx < sortedItems.length && idx < invoiceData.items.length; idx++) {
    const origItem = sortedItems[idx];
    const origEquipmentName = (origItem.equipmentName && origItem.equipmentName.trim() !== '')
        ? origItem.equipmentName.trim()
        : `Equipment ${origItem.equipmentId || origItem.id || 'Unknown'}`;
    const itemCode = invoiceData.items[idx]?.item_code;
    if (itemCode) {
        originalEquipmentNamesMap.set(itemCode, origEquipmentName);
    }
}

const finalVerifiedItems: any[] = [];
for (let i = 0; i < verifiedItems.length; i++) {
    const verifiedItem = verifiedItems[i];
    // Get original equipment name from map or fallback to sortedItems
    const originalEquipmentName = originalEquipmentNamesMap.get(verifiedItem.item_code) ||
        sortedItems[i]?.equipmentName?.trim() ||
        verifiedItem.item_code;

    try {
        const finalCheck = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(verifiedItem.item_code)}`);
        if (finalCheck.data && (finalCheck.data.is_fixed_asset === 1 || finalCheck.data.is_fixed_asset === true)) {
            console.warn(`⚠ FINAL CHECK: Item "${verifiedItem.item_code}" is still a fixed asset. Searching for non-fixed asset version...`);

            // Use ORIGINAL equipment name (from rental item, not ERPNext item_name)
            const normalizedName = originalEquipmentName.replace(/_/g, ' ').trim();

            // Search for non-fixed asset version with same name
            const nonFixedSearch = await this.makeERPNextRequest(
                `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(normalizedName)}"],["is_fixed_asset","=",0]]&limit_page_length=5`
            );

            if (nonFixedSearch.data && nonFixedSearch.data.length > 0) {
                // Found non-fixed asset version - use it
                const nonFixedAsset = nonFixedSearch.data.find((it: any) =>
                    (it.item_name || it.name) === normalizedName && (it.is_fixed_asset === 0 || it.is_fixed_asset === false)
                ) || nonFixedSearch.data[0];

                const nonFixedCode = nonFixedAsset.name || nonFixedAsset.item_code;
                finalVerifiedItems.push({
                    item_code: nonFixedCode.trim(),
                    qty: verifiedItem.qty,
                    rate: verifiedItem.rate,
                    amount: verifiedItem.amount,
                });
                console.log(`✓ FINAL CHECK: Replaced fixed asset "${verifiedItem.item_code}" with non-fixed asset "${nonFixedCode}"`);
            } else {
                // No non-fixed asset version exists - create new one with ORIGINAL equipment name
                console.log(`Creating new non-fixed asset item with ORIGINAL equipment name: "${normalizedName}"...`);
                const newItemCode = await this.syncEquipmentToERPNext(normalizedName);
                finalVerifiedItems.push({
                    item_code: newItemCode.trim(),
                    qty: verifiedItem.qty,
                    rate: verifiedItem.rate,
                    amount: verifiedItem.amount,
                    uom: verifiedItem.uom,
                    income_account: verifiedItem.income_account,
                    cost_center: verifiedItem.cost_center,
                });
                console.log(`✓ FINAL CHECK: Created new non-fixed asset item "${newItemCode}" for ORIGINAL equipment "${normalizedName}"`);
            }
        } else {
            finalVerifiedItems.push(verifiedItem);
        }
    } catch {
        // If check fails, include the item anyway (it was already verified)
        finalVerifiedItems.push(verifiedItem);
    }
}

// CRITICAL: Remove any internal fields before sending to ERPNext
const cleanedItems = finalVerifiedItems.map((item: any) => {
    const cleaned: any = {
        item_code: item.item_code,
        qty: item.qty,
        rate: item.rate,
        amount: item.amount,
        income_account: item.income_account || defaultIncomeAccount,
        cost_center: item.cost_center || defaultCostCenter, // Ensure cost center is present
        uom: item.uom || 'Nos', // TRACE: Final UOM propagation
        conversion_factor: 1,
        base_rate: item.rate,
        base_amount: item.amount,
    };

    console.log(`[Cleaner] Item ${item.item_code} UOM tracing:`, {
        inputUom: item.uom,
        outputUom: cleaned.uom
    });

    // Ensure all values are valid numbers
    if (isNaN(cleaned.qty) || cleaned.qty <= 0) {
        throw new Error(`Invalid qty for item ${item.item_code}: ${cleaned.qty}`);
    }
    if (isNaN(cleaned.rate) || cleaned.rate < 0) {
        throw new Error(`Invalid rate for item ${item.item_code}: ${cleaned.rate}`);
    }
    if (isNaN(cleaned.amount) || cleaned.amount < 0) {
        throw new Error(`Invalid amount for item ${item.item_code}: ${cleaned.amount}`);
    }
    return cleaned;
});

invoiceData.items = cleanedItems;
const skippedCount = originalItemCount - cleanedItems.length;
if (skippedCount > 0) {
    console.log(`=== ${cleanedItems.length} items verified (${skippedCount} items skipped as fixed assets) ===`);
} else {
    console.log(`=== All ${cleanedItems.length} items verified and corrected ===`);
}

// Log final cleaned items structure
console.log('=== FINAL CLEANED ITEMS (before sending to ERPNext) ===');
console.log(`Total items: ${cleanedItems.length}`);
cleanedItems.slice(0, 3).forEach((item: any, idx: number) => {
    console.log(`Item ${idx + 1}:`, {
        item_code: item.item_code,
        item_code_type: typeof item.item_code,
        qty: item.qty,
        qty_type: typeof item.qty,
        rate: item.rate,
        rate_type: typeof item.rate,
        amount: item.amount,
        amount_type: typeof item.amount,
    });
});
if (cleanedItems.length > 3) {
    console.log(`... and ${cleanedItems.length - 3} more items`);
}

// Validate item data
for (const item of invoiceData.items) {
    if (!item.item_code) {
        throw new Error(`Invalid invoice item: missing item_code`);
    }
    if (item.qty <= 0) {
        throw new Error(`Invalid invoice item quantity for item_code ${item.item_code}: ${item.qty}`);
    }
    if (item.rate < 0 || item.amount < 0) {
        throw new Error(`Invalid invoice item rate or amount for item_code ${item.item_code}`);
    }
}
      } else {
    // If no rental items, create a single line item for the rental
    // Dynamically find a suitable item code
    const suitableItemCode = await this.findSuitableItemCode();

    invoiceData.items = [
        {
            item_code: suitableItemCode,
            item_name: `Rental Service - ${rental.rentalNumber}`,
            description: `Equipment rental service for ${rental.rentalNumber}`,
            qty: 1,
            rate: parseFloat(rental.totalAmount?.toString() || '0') || 0,
            amount: parseFloat(rental.totalAmount?.toString() || '0') || 0,
            uom: 'Nos',
            income_account: incomeAccount, // Use dynamically found account
        },
    ];
}

// Don't set calculated amounts - let ERPNext calculate them
// ERPNext will calculate these automatically based on items and taxes
// Setting them manually can cause validation errors (417 Expectation Failed)
// Create invoice in ERPNext
// The endpoint exists (GET works), so 404 on POST usually means API key lacks create permissions
// Try resource API first, then fallback to method-based API
console.log('=== Creating Invoice in ERPNext ===');
console.log('Invoice Data Keys:', Object.keys(invoiceData));
console.log('Items Count:', invoiceData.items?.length || 0);
console.log('Customer:', invoiceData.customer);
console.log('Company:', invoiceData.company);
console.log('Currency:', invoiceData.currency);

// Log each item for debugging
if (invoiceData.items && invoiceData.items.length > 0) {
    console.log('Invoice Items:');
    invoiceData.items.forEach((item: any, index: number) => {
        console.log(`  Item ${index + 1}:`, {
            item_code: item.item_code,
            item_name: item.item_name,
            qty: item.qty,
            rate: item.rate,
            amount: item.amount,
            uom: item.uom
        });
    });
}

// Log full invoice data for debugging - include EVERYTHING
console.log('=== FULL INVOICE DATA BEING SENT TO ERPNEXT ===');
console.log('Items count:', invoiceData.items?.length || 0);
console.log('Taxes count:', invoiceData.taxes?.length || 0);
console.log('Customer:', invoiceData.customer);
console.log('Company:', invoiceData.company);
console.log('Posting Date:', invoiceData.posting_date);
console.log('Due Date:', invoiceData.due_date);

// Log first 3 items in detail (to avoid huge logs)
if (invoiceData.items && invoiceData.items.length > 0) {
    console.log('=== FIRST 3 ITEMS DETAIL ===');
    for (let i = 0; i < Math.min(3, invoiceData.items.length); i++) {
        console.log(`Item ${i + 1}:`, JSON.stringify(invoiceData.items[i], null, 2));
        console.log(`Item ${i + 1} types:`, {
            item_code: typeof invoiceData.items[i].item_code,
            qty: typeof invoiceData.items[i].qty,
            rate: typeof invoiceData.items[i].rate,
            amount: typeof invoiceData.items[i].amount
        });
    }
    if (invoiceData.items.length > 3) {
        console.log(`... and ${invoiceData.items.length - 3} more items`);
    }
}

// Log taxes detail
if (invoiceData.taxes && invoiceData.taxes.length > 0) {
    console.log('=== TAXES DETAIL ===');
    console.log(JSON.stringify(invoiceData.taxes, null, 2));
}

// Full JSON (truncated if too large)
const fullJson = JSON.stringify(invoiceData, null, 2);
if (fullJson.length > 50000) {
    console.log('=== INVOICE DATA (TRUNCATED - too large) ===');
    console.log(fullJson.substring(0, 50000) + '... [truncated]');
} else {
    console.log('=== FULL INVOICE DATA ===');
    console.log(fullJson);
}
console.log('=== END OF INVOICE DATA ===');

let response;
try {
    console.log('Attempting Resource API: /api/resource/Sales Invoice');

    response = await this.makeERPNextRequest('/api/resource/Sales Invoice', {
        method: 'POST',
        body: JSON.stringify(invoiceData),
    });
    console.log('Resource API Success:', response?.data?.name || response?.name || 'No name in response');
} catch (firstError) {
    console.error('Resource API Failed:', firstError instanceof Error ? firstError.message : String(firstError));

    // If resource API fails with 404 or 417, try method-based API
    if (firstError instanceof Error && (firstError.message.includes('404') || firstError.message.includes('417'))) {
        try {
            console.log('Attempting Method API: /api/method/frappe.client.insert');
            response = await this.makeERPNextRequest('/api/method/frappe.client.insert', {
                method: 'POST',
                body: JSON.stringify({
                    doc: invoiceData
                }),
            });
            console.log('Method API Success:', response?.data?.name || response?.name || 'No name in response');
        } catch (secondError) {
            console.error('Method API Also Failed:', secondError instanceof Error ? secondError.message : String(secondError));
            // Provide more specific error message
            if (firstError.message.includes('417')) {
                // Extract detailed error information
                const errorDetails = {
                    customer: invoiceData.customer,
                    company: invoiceData.company,
                    itemsCount: invoiceData.items?.length || 0,
                    itemCodes: invoiceData.items?.map((i: any) => i.item_code) || [],
                    postingDate: invoiceData.posting_date,
                    dueDate: invoiceData.due_date,
                };

                throw new Error(
                    `ERPNext rejected the invoice data (417 Expectation Failed). ` +
                    `Details: Customer="${errorDetails.customer}", Company="${errorDetails.company}", ` +
                    `Items=${errorDetails.itemsCount}, ItemCodes=[${errorDetails.itemCodes.join(', ')}]. ` +
                    `Item details (first item): Qty=${invoiceData.items?.[0]?.qty}, UOM=${invoiceData.items?.[0]?.uom}, Rate=${invoiceData.items?.[0]?.rate}. ` +
                    `Original error from ERPNext: ${firstError.message}`
                );
            }
            throw secondError; // Re-throw the second error if both fail
        }
    } else {
        throw firstError; // Re-throw the first error if not a 404/417
    }
}

// If we reached here, either Resource API or Method API succeeded.
// The actual `makeERPNextRequest` function handles non-2xx responses by throwing errors.
// So, if `response` is available here, it means the request was successful.
return response.data || response;
    } catch (error) {
    // Enhanced error reporting for the entire createInvoice process
    if (error instanceof Error) {
        if (error.message.includes('ERPNext configuration is missing')) {
            throw new Error(`Configuration Error: ${error.message}. Please check your .env file.`);
        } else if (error.message.includes('Network error')) {
            throw new Error(
                `Connection Error: ${error.message}. Please check your ERPNext server and network connection.`
            );
        } else if (error.message.includes('ERPNext API error')) {
            throw new Error(
                `ERPNext API Error: ${error.message}. Please check your ERPNext configuration and API permissions.`
            );
        } else {
            throw new Error(`Invoice Creation Error: ${error.message}`);
        }
    }
}
  }



  // Test ERPNext connection
  static async testConnection(): Promise < boolean > {
    try {

        const response = await this.makeERPNextRequest('/api/method/frappe.auth.get_logged_user');

        return true;
    } catch(error) {

        return false;
    }
}

  // Get available items from ERPNext
  static async getAvailableItems(): Promise < any[] > {
    try {

        const response = await this.makeERPNextRequest('/api/resource/Item?limit_page_length=100');

        const items = response.data || [];

        // Normalize item data - ERPNext uses 'name' as item_code
        return items.map((item: any) => ({
            ...item,
            item_code: item.item_code || item.name, // Use name if item_code is not present
            item_name: item.item_name || item.item_name || item.name, // Ensure item_name exists
        }));
    } catch(error) {

        return [];
    }
}

  // Get available accounts from ERPNext
  static async getAvailableAccounts(): Promise < any[] > {
    try {

        const response = await this.makeERPNextRequest('/api/resource/Account?limit_page_length=100');

        return response.data || [];
    } catch(error) {

        return [];
    }
}

  // Find a suitable tax account for the company
  // Priority: "Output VAT 15%" accounts (as used in existing invoices)
  static async findSuitableTaxAccount(companyName: string): Promise < string > {
    try {
        const accounts = await this.getAvailableAccounts();

        // Look for tax accounts - prioritize by company match, then by name
        const taxAccounts = accounts.filter(
            account => account.account_type === 'Tax'
        );

        if(taxAccounts.length > 0) {
    // First, try to find accounts that belong to the company
    const companyTaxAccounts = taxAccounts.filter(
        account => account.company === companyName || !account.company
    );

    if (companyTaxAccounts.length > 0) {
        // HIGHEST PRIORITY: "Output VAT 15%" accounts (as used in existing invoices)
        const outputVATAccount = companyTaxAccounts.find(
            account =>
                account.account_name?.toLowerCase().includes('output vat 15') ||
                account.name?.toLowerCase().includes('output vat 15') ||
                account.account_name?.toLowerCase().includes('output vat') ||
                account.name?.toLowerCase().includes('output vat')
        );
        if (outputVATAccount) {
            console.log(`Found Output VAT 15% account: ${outputVATAccount.name}`);
            return outputVATAccount.name;
        }

        // Second priority: accounts with "VAT" in the name
        const vatAccount = companyTaxAccounts.find(
            account =>
                account.account_name?.toLowerCase().includes('vat') ||
                account.name?.toLowerCase().includes('vat')
        );
        if (vatAccount) {
            console.log(`Found VAT account: ${vatAccount.name}`);
            return vatAccount.name;
        }

        // Third priority: accounts with "Duties" in the name
        const dutiesAccount = companyTaxAccounts.find(
            account =>
                account.account_name?.toLowerCase().includes('duties') ||
                account.name?.toLowerCase().includes('duties')
        );
        if (dutiesAccount) {
            console.log(`Found Duties account: ${dutiesAccount.name}`);
            return dutiesAccount.name;
        }

        // Use first company tax account
        console.log(`Using first company tax account: ${companyTaxAccounts[0].name}`);
        return companyTaxAccounts[0].name;
    }

    // If no company-specific account, search all tax accounts
    // HIGHEST PRIORITY: "Output VAT 15%" accounts
    const outputVATAccount = taxAccounts.find(
        account =>
            account.account_name?.toLowerCase().includes('output vat 15') ||
            account.name?.toLowerCase().includes('output vat 15') ||
            account.account_name?.toLowerCase().includes('output vat') ||
            account.name?.toLowerCase().includes('output vat')
    );
    if (outputVATAccount) {
        console.warn(`Using Output VAT 15% account from different company: ${outputVATAccount.name}`);
        return outputVATAccount.name;
    }

    // Second priority: accounts with "VAT" in the name
    const vatAccount = taxAccounts.find(
        account =>
            account.account_name?.toLowerCase().includes('vat') ||
            account.name?.toLowerCase().includes('vat')
    );
    if (vatAccount) {
        console.warn(`Using VAT account from different company: ${vatAccount.name}`);
        return vatAccount.name;
    }

    // Third priority: accounts with "Duties" in the name
    const dutiesAccount = taxAccounts.find(
        account =>
            account.account_name?.toLowerCase().includes('duties') ||
            account.name?.toLowerCase().includes('duties')
    );
    if (dutiesAccount) {
        console.warn(`Using Duties account from different company: ${dutiesAccount.name}`);
        return dutiesAccount.name;
    }

    // Use first available tax account
    console.warn(`Using first available tax account: ${taxAccounts[0].name}`);
    return taxAccounts[0].name;
}

// Last resort: use "Output VAT 15% - SND" (as used in existing invoices)
console.warn('No tax account found, using fallback: Output VAT 15% - SND');
return 'Output VAT 15% - SND';
    } catch (error) {
    console.error('Error finding tax account:', error);
    return 'Output VAT 15% - SND'; // Fallback - matches existing invoices
}
  }

  // Find a suitable income account for the company
  static async findSuitableIncomeAccount(): Promise < string > {
    try {
        const accounts = await this.getAvailableAccounts();

        // Look for income/sales accounts
        const incomeAccounts = accounts.filter(
            account =>
                !account.is_group && (
                    account.account_type === 'Income' ||
                    account.account_name?.toLowerCase().includes('service') ||
                    account.account_name?.toLowerCase().includes('rental') ||
                    account.name?.toLowerCase().includes('service') ||
                    account.name?.toLowerCase().includes('rental')
                )
        );

        // Priority 1: "Sales - SND" (found in diagnostics as standard)
        const salesSND = incomeAccounts.find(a => a.name === 'Sales - SND');
        if(salesSND) return 'Sales - SND';

        // Priority 2: "Service - SND" (found in diagnostics)
        const serviceSND = incomeAccounts.find(a => a.name === 'Service - SND');
        if(serviceSND) return 'Service - SND';

        if(incomeAccounts.length > 0) {
    return incomeAccounts[0].name;
}

return 'Service - SND'; // Final fallback based on diagnostics
    } catch (error) {
    console.error('Error finding income account:', error);
    return 'Service - SND';
}
  }

  // Find a suitable cost center for the company
  static async findSuitableCostCenter(): Promise < string > {
    try {
        const response = await this.makeERPNextRequest('/api/resource/Cost Center?filters=[["is_group","=",0]]&limit_page_length=100');
        const costCenters = response.data || [];

        // Priority 1: "Main - SND" (found in diagnostics)
        const mainSND = costCenters.find((cc: any) => cc.name === 'Main - SND');
        if(mainSND) return 'Main - SND';

        // Priority 2: Any account with "Main"
        const anyMain = costCenters.find((cc: any) => cc.name.toLowerCase().includes('main'));
        if(anyMain) return anyMain.name;

        if(costCenters.length > 0) {
    return costCenters[0].name;
}

return 'Main - SND'; // Fallback
    } catch (error) {
    console.error('Error finding cost center:', error);
    return 'Main - SND';
}
  }

  // Find a suitable receivable account (debit_to)
  static async findSuitableReceivableAccount(): Promise < string > {
    try {
        const accounts = await this.getAvailableAccounts();

        // Look for receivable accounts
        const receivableAccounts = accounts.filter(
            account =>
                !account.is_group && (
                    account.account_type === 'Receivable' ||
                    account.name.toLowerCase().includes('debtor') ||
                    account.account_name?.toLowerCase().includes('receivable')
                )
        );

        // Priority 1: "Debtors - SND" (found in diagnostics)
        const debtorsSND = receivableAccounts.find(a => a.name === 'Debtors - SND');
        if(debtorsSND) return 'Debtors - SND';

        if(receivableAccounts.length > 0) {
    return receivableAccounts[0].name;
}

return 'Debtors - SND'; // Fallback
    } catch (error) {
    console.error('Error finding receivable account:', error);
    return 'Debtors - SND';
}
  }

  // Find a suitable item code for rental services
  static async findSuitableItemCode(): Promise < string > {
    try {
        const items = await this.getAvailableItems();

        if(items.length === 0) {
    throw new Error('No items found in ERPNext. Please create at least one Item in ERPNext before creating invoices.');
}

// Look for common service-related items
const serviceItems = items.filter(
    item => {
        const itemCode = item.item_code || item.name;
        const itemName = item.item_name || item.item_name;
        return itemName?.toLowerCase().includes('service') ||
            itemName?.toLowerCase().includes('rental') ||
            itemName?.toLowerCase().includes('equipment') ||
            itemCode?.toLowerCase().includes('service') ||
            itemCode?.toLowerCase().includes('rental');
    }
);

if (serviceItems.length > 0) {
    const code = serviceItems[0].item_code || serviceItems[0].name;
    if (code) return code;
}

// If no service items, use the first available item
if (items.length > 0) {
    const code = items[0].item_code || items[0].name;
    if (code) return code;
}

// This should never be reached due to the check above, but just in case
throw new Error('No suitable item code found in ERPNext. Please create items in ERPNext before creating invoices.');
    } catch (error) {
    // Re-throw with better error message
    if (error instanceof Error) {
        if (error.message.includes('No items found') || error.message.includes('No suitable item')) {
            throw error;
        }
        throw new Error(`Failed to find suitable item code: ${error.message}. Please ensure items exist in ERPNext.`);
    }
    throw new Error(`Failed to find suitable item code: ${String(error)}. Please ensure items exist in ERPNext.`);
}
  }

  // Sync equipment name to ERPNext item
  static async syncEquipmentToERPNext(equipmentName: string, equipmentId ?: string, plateNumber ?: string): Promise < string > {
    try {
        // Normalize name for comparison
        const normalizedName = equipmentName.toUpperCase().trim();

        // Priority 1: Search by name exactly
        const searchResponse = await this.makeERPNextRequest(`/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(normalizedName)}"]]&limit_page_length=5`);

        if(searchResponse.data && searchResponse.data.length > 0) {
    // Found match(es), prioritize non-fixed assets
    const nonFixedAsset = searchResponse.data.find((it: any) => it.is_fixed_asset === 0 || it.is_fixed_asset === false);

    if (nonFixedAsset) {
        console.log(`✓ Found existing non-fixed asset item in ERPNext: ${nonFixedAsset.name || nonFixedAsset.item_code}`);
        return nonFixedAsset.name || nonFixedAsset.item_code;
    }

    // If only fixed assets found, search for non-fixed asset with same item_name
    console.warn(`⚠ Only fixed asset item found for "${normalizedName}". Attempting to find/create non-fixed asset version...`);
}

// Priority 2: Try to find a non-fixed asset version by searching (in case item_code != item_name)
const nonFixedSearch = await this.makeERPNextRequest(
    `/api/resource/Item?filters=[["item_name","=","${encodeURIComponent(normalizedName)}"],["is_fixed_asset","=",0]]&limit_page_length=5`
);

if (nonFixedSearch.data && nonFixedSearch.data.length > 0) {
    const item = nonFixedSearch.data[0];
    console.log(`✓ Found existing non-fixed asset item (search match): ${item.name || item.item_code}`);
    return item.name || item.item_code;
}

// Item doesn't exist, create it
console.log(`Creating new equipment item in ERPNext with ORIGINAL name: ${normalizedName}`);

// Try multiple code variants to avoid duplicates
const codeVariants = [
    normalizedName, // "1392 DOZER" (original format)
    normalizedName.replace(/\s+/g, '-'), // "1392-DOZER"
    normalizedName.replace(/\s+/g, '_'), // "1392_DOZER"
    normalizedName.replace(/[^a-zA-Z0-9]/g, ''), // "1392DOZER"
];

// Add variant with ID if provided
if (equipmentId) {
    codeVariants.push(`${normalizedName}-${equipmentId}`);
    codeVariants.push(`${equipmentId}-${normalizedName}`);
}

// Remove duplicates
const uniqueVariants = [...new Set(codeVariants)];

for (const variant of uniqueVariants) {
    try {
        // Check if this variant exists first (as a fixed asset or anything else)
        try {
            const check = await this.makeERPNextRequest(`/api/resource/Item/${encodeURIComponent(variant)}`);
            if (check.data) {
                // If it exists but is a fixed asset, we can't use this item_code variant directly
                if (check.data.is_fixed_asset === 1 || check.data.is_fixed_asset === true) {
                    console.warn(`Variant "${variant}" is a fixed asset, skipping...`);
                    continue;
                }
                // If it exists and is not fixed asset, return it!
                return check.data.name || check.data.item_code;
            }
        } catch {
            // Not found, proceed with creation
        }

        const newItemData = {
            doctype: 'Item',
            item_code: variant, // Try original format first
            item_name: normalizedName, // Use original equipment name exactly
            item_group: 'Equipment', // Match your ERPNext item group
            stock_uom: 'Nos',
            is_stock_item: 0, // Equipment rental, not stock item
            is_fixed_asset: 0, // CRITICAL: Not a fixed asset (rental equipment, not company asset)
            has_serial_no: 0,
            has_batch_no: 0,
            show_in_website: 0,
            include_item_in_manufacturing: 0,
            valuation_method: 'FIFO',
        };

        const response = await this.makeERPNextRequest('/api/resource/Item', {
            method: 'POST',
            body: JSON.stringify(newItemData),
        });

        console.log(`✓ Successfully created item in ERPNext: ${response.data.name}`);
        return response.data.name;
    } catch (createError) {
        console.error(`Failed to create item variant ${variant}:`, createError instanceof Error ? createError.message : String(createError));
        // Continue to next variant
    }
}

// If all variants fail, try searching one last time for ANY item with that name
const finalSearch = await this.makeERPNextRequest(`/api/resource/Item?filters=[["item_name","like","${encodeURIComponent(`%${normalizedName}%`)}"]]&limit_page_length=5`);
if (finalSearch.data && finalSearch.data.length > 0) {
    // Prefer non-fixed asset
    const item = finalSearch.data.find((it: any) => it.is_fixed_asset === 0 || it.is_fixed_asset === false) || finalSearch.data[0];
    console.warn(`Using existing item after creation failed: ${item.name}`);
    return item.name || item.item_code;
}

throw new Error(`Failed to create or find item for equipment: ${normalizedName}`);
    } catch (error) {
    console.error('Error syncing equipment to ERPNext:', error);
    throw error;
}
  }

  // Update an existing invoice
  static async updateInvoice(invoiceId: string, invoiceData: any): Promise < any > {
    try {
        const response = await this.makeERPNextRequest(`/api/resource/Sales Invoice/${encodeURIComponent(invoiceId)}`, {
            method: 'PUT',
            body: JSON.stringify(invoiceData),
        });

        return response.data || response;
    } catch(error) {
        console.error(`Error updating invoice ${invoiceId}:`, error);
        throw error;
    }
}

  // Submit an existing invoice
  static async submitInvoice(invoiceId: string): Promise < any > {
    try {
        const response = await this.makeERPNextRequest(`/api/resource/Sales Invoice/${encodeURIComponent(invoiceId)}`, {
            method: 'PUT',
            body: JSON.stringify({ docstatus: 1 }), // 1 = Submitted
        });

        return response.data || response;
    } catch(error) {
        console.error(`Error submitting invoice ${invoiceId}:`, error);
        throw error;
    }
}

  // Cancel an existing invoice
  static async cancelInvoice(invoiceId: string): Promise < any > {
    try {
        const response = await this.makeERPNextRequest(`/api/resource/Sales Invoice/${encodeURIComponent(invoiceId)}`, {
            method: 'PUT',
            body: JSON.stringify({ docstatus: 2 }), // 2 = Cancelled
        });

        return response.data || response;
    } catch(error) {
        console.error(`Error cancelling invoice ${invoiceId}:`, error);
        throw error;
    }
}

  // Delete an existing invoice
  static async deleteInvoice(invoiceId: string): Promise < any > {
    try {
        const response = await this.makeERPNextRequest(`/api/resource/Sales Invoice/${encodeURIComponent(invoiceId)}`, {
            method: 'DELETE',
        });

        return response.data || response;
    } catch(error) {
        console.error(`Error deleting invoice ${invoiceId}:`, error);
        throw error;
    }
}

  // Get invoice details
  static async getInvoice(invoiceId: string): Promise < any > {
    try {
        const response = await this.makeERPNextRequest(`/api/resource/Sales Invoice/${encodeURIComponent(invoiceId)}`);
        return response.data || response;
    } catch(error) {
        console.error(`Error getting invoice ${invoiceId}:`, error);
        throw error;
    }
}
}
